# Agent-Audit v0.10.0 语义层重构 - Claude Code 实施 Prompt

> **用途**: 将此文档内容完整复制给 Claude Code，让其按照规范实施 AGENT-034/018 语义层优化。

---

## 任务概述

你需要为 `agent-audit` 安全扫描工具实施 **AGENT-034/018 语义层重构**，这是 v0.10.0 的核心优化，目标是大幅减少假阳性。

### 背景数据

```
当前状态 (v0.9.0):
├── SWE-agent: 54 findings (目标 ≤20)
│   └── AGENT-034: 33 个，大部分是 asyncio.run(), re.compile() FP
├── Generative Agents: 11 findings (目标 0)
│   └── AGENT-018: 11 个，全部是 Python set() 操作 FP
└── 预期收益: -50% findings，无真阳性损失
```

### 核心问题

1. **AGENT-034** (Tool Input Validation): 当前基于语法模式 `@tool + str参数` 触发，但会误报 `asyncio.run()`, `re.compile()` 等安全的 Python 内置操作
2. **AGENT-018** (Memory Poisoning): 当前检测 `.add()`, `.append()` 等方法，但会误报 Python 的 `set()`, `list.append()` 操作

### 解决方案

**语义层 Agent 边界检测**: 在规则触发前，先判断代码是否在 Agent 执行上下文中。

---

## 实施指令

### Phase 1: 创建 Agent 边界检测器

**创建文件**: `packages/audit/agent_audit/analysis/agent_boundary_detector.py`

```python
"""
Agent Boundary Detection for Semantic-Layer False Positive Reduction.

This module determines if code is within an Agent execution boundary,
which is required for AGENT-034/018 rules to fire.

Agent Context Hierarchy:
1. File Context - Does file import Agent frameworks?
2. Class Context - Is class an Agent/Tool subclass?  
3. Function Context - Does function have @tool decorator?
4. Call Context - Is method called on an Agent object?
"""

from __future__ import annotations

import ast
import re
from dataclasses import dataclass, field
from enum import Enum
from typing import Dict, List, Optional, Set, Tuple


class AgentContextLevel(Enum):
    """Level of Agent context detection."""
    NONE = "none"           # Not in Agent context
    FILE = "file"           # File imports Agent framework
    CLASS = "class"         # Inside Agent/Tool class
    FUNCTION = "function"   # Inside @tool decorated function
    CALL = "call"           # Method called on Agent object


@dataclass
class AgentBoundaryResult:
    """Result of Agent boundary detection."""
    is_agent_context: bool
    context_level: AgentContextLevel
    framework_detected: Optional[str] = None
    confidence: float = 0.0
    reason: str = ""
    in_tool_function: bool = False
    in_agent_class: bool = False
    has_agent_imports: bool = False


# Agent framework imports
AGENT_FRAMEWORK_IMPORTS: Dict[str, List[str]] = {
    'langchain': ['langchain', 'langchain_core', 'langchain_community', 'langchain_openai', 'langchain_anthropic'],
    'crewai': ['crewai'],
    'autogen': ['autogen', 'pyautogen'],
    'openai_agents': ['agents'],
    'llama_index': ['llama_index'],
    'haystack': ['haystack'],
    'semantic_kernel': ['semantic_kernel'],
    'google_adk': ['google.adk', 'google.generativeai'],
}

ALL_AGENT_IMPORTS: Set[str] = set()
for imports in AGENT_FRAMEWORK_IMPORTS.values():
    ALL_AGENT_IMPORTS.update(imports)


# Agent/Tool base classes
AGENT_BASE_CLASSES: Set[str] = {
    'BaseTool', 'Tool', 'StructuredTool', 'BaseAgent', 'Agent', 'AgentExecutor',
    'BaseRetriever', 'BaseMemory', 'RunnableLambda', 'RunnableSequence',
    'Task', 'Crew', 'Process', 'AssistantAgent', 'UserProxyAgent', 
    'ConversableAgent', 'GroupChat', 'GroupChatManager', 'QueryEngine', 'FunctionTool',
}

TOOL_DECORATORS: Set[str] = {'tool', 'function_tool', 'kernel_function'}


# Safe builtin operations that should NEVER trigger AGENT-034
SAFE_BUILTIN_CALLS: Set[str] = {
    # Async operations
    'asyncio.run', 'asyncio.create_task', 'asyncio.gather', 'asyncio.wait', 
    'asyncio.sleep', 'asyncio.wait_for',
    # Regex operations
    're.compile', 're.match', 're.search', 're.findall', 're.sub', 're.split',
    # JSON operations
    'json.loads', 'json.dumps', 'json.load', 'json.dump',
    # Type operations
    'type', 'isinstance', 'issubclass', 'hasattr', 'getattr', 'setattr',
    # Collections
    'list', 'dict', 'set', 'tuple', 'frozenset', 'len', 'sorted', 'reversed',
    'enumerate', 'zip', 'map', 'filter',
    # Math
    'int', 'float', 'abs', 'min', 'max', 'sum', 'round',
    # Path operations
    'pathlib.Path', 'os.path.join', 'os.path.exists', 'os.path.dirname',
    'os.path.basename', 'os.path.isfile',
    # Logging
    'print', 'logging.info', 'logging.debug', 'logging.warning', 'logging.error',
}


# Python builtin types (NOT Agent memory)
PYTHON_BUILTIN_TYPES: Set[str] = {
    'set', 'frozenset', 'list', 'dict', 'collections.deque',
    'collections.OrderedDict', 'collections.defaultdict',
    'queue.Queue', 'queue.PriorityQueue',
}

# Variable patterns that indicate Python builtins, not Agent memory
BUILTIN_VARIABLE_PATTERNS: List[re.Pattern] = [
    re.compile(r'^_?(?:seen|visited|processed|checked|done|used)_?\w*$', re.I),
    re.compile(r'^_?(?:temp|tmp|local|internal)_?\w*$', re.I),
    re.compile(r'^_?(?:ids|keys|values|items|names|tags|labels)$', re.I),
    re.compile(r'^_?\w*(?:_set|_list|_dict|_queue|_stack)$', re.I),
]

# Agent memory indicators
AGENT_MEMORY_INDICATORS: List[re.Pattern] = [
    re.compile(r'memory', re.I),
    re.compile(r'store', re.I),
    re.compile(r'vector', re.I),
    re.compile(r'embed', re.I),
    re.compile(r'retriev', re.I),
    re.compile(r'context', re.I),
    re.compile(r'history', re.I),
    re.compile(r'conversation', re.I),
    re.compile(r'message', re.I),
    re.compile(r'chat', re.I),
    re.compile(r'db', re.I),
    re.compile(r'database', re.I),
    re.compile(r'persist', re.I),
]


class AgentBoundaryDetector:
    """Detects whether code is within an Agent execution boundary."""
    
    def __init__(self):
        self._file_imports: Set[str] = set()
        self._detected_framework: Optional[str] = None
    
    def analyze_file(self, source: str) -> AgentBoundaryResult:
        """Analyze a file to determine if it contains Agent code."""
        try:
            tree = ast.parse(source)
        except SyntaxError:
            return AgentBoundaryResult(
                is_agent_context=False,
                context_level=AgentContextLevel.NONE,
                reason="Failed to parse file"
            )
        
        self._file_imports = self._extract_imports(tree)
        self._detected_framework = self._detect_framework(self._file_imports)
        
        has_agent_imports = self._detected_framework is not None
        
        return AgentBoundaryResult(
            is_agent_context=has_agent_imports,
            context_level=AgentContextLevel.FILE if has_agent_imports else AgentContextLevel.NONE,
            framework_detected=self._detected_framework,
            confidence=0.7 if has_agent_imports else 0.0,
            reason=f"Framework detected: {self._detected_framework}" if has_agent_imports else "No Agent framework imports",
            has_agent_imports=has_agent_imports,
        )
    
    def _extract_imports(self, tree: ast.AST) -> Set[str]:
        """Extract all import statements from AST."""
        imports = set()
        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for alias in node.names:
                    imports.add(alias.name.split('.')[0])
            elif isinstance(node, ast.ImportFrom):
                if node.module:
                    imports.add(node.module.split('.')[0])
        return imports
    
    def _detect_framework(self, imports: Set[str]) -> Optional[str]:
        """Detect Agent framework from imports."""
        for framework, modules in AGENT_FRAMEWORK_IMPORTS.items():
            for module in modules:
                module_base = module.split('.')[0]
                if module_base in imports:
                    return framework
        return None
    
    def is_in_tool_function(self, node: ast.FunctionDef) -> bool:
        """Check if a function has @tool decorator."""
        for decorator in node.decorator_list:
            dec_name = self._get_decorator_name(decorator)
            if dec_name in TOOL_DECORATORS:
                return True
        return False
    
    def _get_decorator_name(self, decorator: ast.expr) -> str:
        """Get the name of a decorator."""
        if isinstance(decorator, ast.Name):
            return decorator.id
        elif isinstance(decorator, ast.Attribute):
            return decorator.attr
        elif isinstance(decorator, ast.Call):
            return self._get_decorator_name(decorator.func)
        return ""
    
    def is_in_agent_class(self, node: ast.ClassDef) -> bool:
        """Check if a class inherits from Agent/Tool base classes."""
        for base in node.bases:
            base_name = self._get_base_name(base)
            if base_name in AGENT_BASE_CLASSES:
                return True
        return False
    
    def _get_base_name(self, node: ast.expr) -> str:
        """Get the name of a base class."""
        if isinstance(node, ast.Name):
            return node.id
        elif isinstance(node, ast.Attribute):
            return node.attr
        return ""
    
    def is_safe_builtin_call(self, func_name: str) -> bool:
        """Check if a function call is a safe Python builtin."""
        if func_name in SAFE_BUILTIN_CALLS:
            return True
        parts = func_name.split('.')
        if len(parts) >= 2:
            module = parts[0]
            if module in {'asyncio', 're', 'json', 'logging', 'pathlib'}:
                return True
        return False
    
    def is_python_builtin_collection(
        self,
        node: ast.Call,
        var_name: Optional[str] = None,
    ) -> Tuple[bool, str]:
        """Check if a call is on a Python builtin collection."""
        func_name = self._get_call_name(node)
        if not func_name:
            return (False, "")
        
        # Check builtin type constructor
        if func_name in PYTHON_BUILTIN_TYPES:
            return (True, f"Python builtin: {func_name}()")
        
        # Check method on builtin-named variable
        if '.' in func_name:
            parts = func_name.split('.')
            obj_name = parts[0]
            for pattern in BUILTIN_VARIABLE_PATTERNS:
                if pattern.match(obj_name):
                    return (True, f"Builtin collection variable: {obj_name}")
        
        if var_name:
            for pattern in BUILTIN_VARIABLE_PATTERNS:
                if pattern.match(var_name):
                    return (True, f"Builtin collection variable: {var_name}")
        
        return (False, "")
    
    def is_agent_memory_operation(
        self,
        node: ast.Call,
        var_name: Optional[str] = None,
    ) -> Tuple[bool, str]:
        """Check if a call is an Agent memory operation."""
        is_builtin, _ = self.is_python_builtin_collection(node, var_name)
        if is_builtin:
            return (False, "Python builtin, not Agent memory")
        
        func_name = self._get_call_name(node)
        if not func_name:
            return (False, "Unknown function")
        
        if '.' in func_name:
            parts = func_name.split('.')
            obj_name = parts[0]
            for pattern in AGENT_MEMORY_INDICATORS:
                if pattern.search(obj_name):
                    return (True, f"Agent memory indicator: {obj_name}")
        
        if var_name:
            for pattern in AGENT_MEMORY_INDICATORS:
                if pattern.search(var_name):
                    return (True, f"Agent memory indicator: {var_name}")
        
        return (False, "No Agent memory indicators")
    
    def _get_call_name(self, node: ast.Call) -> Optional[str]:
        """Get the full name of a function call."""
        if isinstance(node.func, ast.Name):
            return node.func.id
        elif isinstance(node.func, ast.Attribute):
            parts = []
            current = node.func
            while isinstance(current, ast.Attribute):
                parts.append(current.attr)
                current = current.value
            if isinstance(current, ast.Name):
                parts.append(current.id)
            parts.reverse()
            return '.'.join(parts)
        return None


def should_check_agent_034(
    func_name: str,
    has_agent_imports: bool,
    is_tool_function: bool,
    call_name: Optional[str] = None,
) -> Tuple[bool, str]:
    """Determine if AGENT-034 check should be performed."""
    detector = AgentBoundaryDetector()
    
    if not has_agent_imports:
        return (False, "No Agent framework imports in file")
    
    if not is_tool_function:
        return (False, "Function does not have @tool decorator")
    
    if call_name and detector.is_safe_builtin_call(call_name):
        return (False, f"Safe builtin call: {call_name}")
    
    return (True, "In Agent context with dangerous operation")


def should_check_agent_018(
    node: ast.Call,
    has_agent_imports: bool,
    var_name: Optional[str] = None,
) -> Tuple[bool, str]:
    """Determine if AGENT-018 check should be performed."""
    detector = AgentBoundaryDetector()
    
    if not has_agent_imports:
        return (False, "No Agent framework imports in file")
    
    is_builtin, builtin_reason = detector.is_python_builtin_collection(node, var_name)
    if is_builtin:
        return (False, builtin_reason)
    
    is_memory, memory_reason = detector.is_agent_memory_operation(node, var_name)
    if not is_memory:
        return (False, memory_reason)
    
    return (True, f"Agent memory operation: {memory_reason}")
```

### Phase 2: 修改 dangerous_operation_analyzer.py

**修改文件**: `packages/audit/agent_audit/analysis/dangerous_operation_analyzer.py`

在文件顶部添加安全内置函数集合:

```python
# === 新增: 安全内置函数 (v0.10.0) ===
SAFE_BUILTIN_FUNCTIONS: Set[str] = {
    # Async - not code execution
    'asyncio.run', 'asyncio.create_task', 'asyncio.gather',
    'asyncio.wait', 'asyncio.sleep', 'asyncio.wait_for',
    # Regex - pattern matching, not execution
    're.compile', 're.match', 're.search', 're.findall',
    're.sub', 're.split', 're.subn',
    # JSON - parsing, not execution
    'json.loads', 'json.dumps', 'json.load', 'json.dump',
    # Type operations
    'type', 'isinstance', 'issubclass', 'hasattr', 'getattr',
    # Collections
    'list', 'dict', 'set', 'tuple', 'frozenset',
    'len', 'sorted', 'reversed', 'enumerate', 'zip', 'map', 'filter',
    # Logging/printing
    'print', 'logging.info', 'logging.debug', 'logging.warning', 'logging.error',
}


def is_safe_builtin(func_name: str) -> bool:
    """Check if function is a safe Python builtin."""
    if func_name in SAFE_BUILTIN_FUNCTIONS:
        return True
    parts = func_name.split('.')
    if parts[0] in {'asyncio', 're', 'json', 'logging', 'pathlib'}:
        return True
    return False
```

修改 `should_flag_tool_input` 函数，在返回前检查安全内置:

```python
def should_flag_tool_input(
    func_name: str,
    func_body: str,
    param_names: List[str],
    param_types: Optional[List[str]] = None,
    has_validation: bool = False,
) -> Tuple[bool, float, str]:
    """Determine if a tool should be flagged for AGENT-034."""
    
    validation_factor = 0.5 if has_validation else 1.0
    
    result = analyze_tool_for_dangerous_operations(
        func_name=func_name,
        func_body=func_body,
        param_names=param_names,
        param_types=param_types,
    )
    
    if not result.has_dangerous_operation:
        return (False, 0.0, result.reason)
    
    # === 新增 v0.10.0: 安全内置检查 ===
    if is_safe_builtin(result.operation_function):
        return (False, 0.0, f"Safe builtin: {result.operation_function}")
    
    final_confidence = result.confidence * validation_factor
    
    if final_confidence < 0.50:
        return (False, final_confidence, f"{result.reason} (confidence below threshold)")
    
    return (True, final_confidence, result.reason)
```

### Phase 3: 修改 python_scanner.py

**修改文件**: `packages/audit/agent_audit/scanners/python_scanner.py`

#### Step 3.1: 在文件顶部添加导入

```python
from agent_audit.analysis.agent_boundary_detector import (
    AgentBoundaryDetector,
    should_check_agent_034,
    should_check_agent_018,
)
```

#### Step 3.2: 在 PythonScanner.__init__ 中添加实例变量

```python
def __init__(self, ...):
    # ... existing code ...
    
    # v0.10.0: Agent boundary detection
    self._agent_detector = AgentBoundaryDetector()
    self._has_agent_imports = False
    self._detected_framework = None
```

#### Step 3.3: 在 scan 方法开头添加文件级检测

找到 `scan` 或 `_scan_python` 方法，在 AST 解析后添加:

```python
def scan(self, ...):
    # ... existing AST parsing ...
    
    # v0.10.0: Analyze file for Agent context
    file_context = self._agent_detector.analyze_file(self.source)
    self._has_agent_imports = file_context.has_agent_imports
    self._detected_framework = file_context.framework_detected
    
    # ... rest of scan logic ...
```

#### Step 3.4: 修改 _check_tool_no_input_validation (AGENT-034)

在方法开头添加 Agent 边界检查:

```python
def _check_tool_no_input_validation(
    self, node: ast.FunctionDef
) -> Optional[Dict[str, Any]]:
    """AGENT-034: Detect tool functions without input validation."""
    
    # === v0.10.0: Agent boundary check ===
    if not self._has_agent_imports:
        return None  # Not in Agent context - skip
    
    # Check if it's a tool function
    is_tool = self._has_tool_decorator(node) or 'tool' in node.name.lower()
    
    if not is_tool:
        return None
    
    # ... 保留现有的参数提取逻辑 ...
    
    # 在 should_flag_tool_input 调用后，dangerous_operation_analyzer
    # 现在会自动过滤安全内置函数
    
    # ... 保留现有的返回逻辑 ...
```

#### Step 3.5: 修改 _check_memory_poisoning (AGENT-018)

添加 Python 内置集合过滤:

```python
def _check_memory_poisoning(self, node: ast.Call) -> Optional[Dict[str, Any]]:
    """ASI-06: Detect unsanitized writes to vector databases or memory stores."""
    
    # v0.3.2: Skip framework internal code
    file_path = str(self.file_path) if self.file_path else ''
    if self._is_framework_internal_path(file_path):
        return None
    
    # === v0.10.0: Agent boundary check ===
    if not self._has_agent_imports:
        return None  # Not in Agent context - skip
    
    func_name = self._get_call_name(node)
    if not func_name:
        return None
    
    method_name = func_name.split('.')[-1] if '.' in func_name else func_name
    
    if method_name not in self.MEMORY_WRITE_FUNCTIONS:
        return None
    
    # === v0.10.0: Python builtin filter ===
    # Extract receiver variable name for better detection
    receiver_name = self._extract_receiver_name(node)
    
    is_builtin, builtin_reason = self._agent_detector.is_python_builtin_collection(
        node=node,
        var_name=receiver_name,
    )
    if is_builtin:
        return None  # Skip Python builtins like set(), list.append()
    
    # === v0.10.0: Agent memory indicator check ===
    is_memory, memory_reason = self._agent_detector.is_agent_memory_operation(
        node=node,
        var_name=receiver_name,
    )
    if not is_memory:
        return None  # Not an Agent memory operation
    
    # ... 保留现有的 context analysis 逻辑 ...
```

#### Step 3.6: 添加辅助方法 _extract_receiver_name

```python
def _extract_receiver_name(self, node: ast.Call) -> Optional[str]:
    """Extract the receiver variable name from a method call."""
    if isinstance(node.func, ast.Attribute):
        if isinstance(node.func.value, ast.Name):
            return node.func.value.id
        elif isinstance(node.func.value, ast.Attribute):
            # Handle chained calls like obj.memory.add()
            parts = []
            current = node.func.value
            while isinstance(current, ast.Attribute):
                parts.append(current.attr)
                current = current.value
            if isinstance(current, ast.Name):
                parts.append(current.id)
            parts.reverse()
            return '.'.join(parts)
    return None
```

### Phase 4: 添加单元测试

**创建文件**: `packages/audit/tests/test_analysis/test_agent_boundary_detector.py`

```python
"""Tests for Agent boundary detection."""

import ast
import pytest
from agent_audit.analysis.agent_boundary_detector import (
    AgentBoundaryDetector,
    should_check_agent_034,
    should_check_agent_018,
    AgentContextLevel,
)


class TestAgentBoundaryDetector:
    """Test Agent boundary detection."""
    
    def test_file_with_langchain_import(self):
        """File with LangChain import is Agent context."""
        source = '''
from langchain.tools import tool

@tool
def my_tool(query: str) -> str:
    return query
'''
        detector = AgentBoundaryDetector()
        result = detector.analyze_file(source)
        
        assert result.is_agent_context is True
        assert result.framework_detected == 'langchain'
    
    def test_file_without_agent_import(self):
        """Regular Python file is not Agent context."""
        source = '''
import asyncio
import re

async def main():
    result = await asyncio.gather(task1(), task2())
    return result
'''
        detector = AgentBoundaryDetector()
        result = detector.analyze_file(source)
        
        assert result.is_agent_context is False
        assert result.framework_detected is None
    
    def test_safe_builtin_asyncio_run(self):
        """asyncio.run is safe builtin."""
        detector = AgentBoundaryDetector()
        assert detector.is_safe_builtin_call('asyncio.run') is True
    
    def test_safe_builtin_re_compile(self):
        """re.compile is safe builtin."""
        detector = AgentBoundaryDetector()
        assert detector.is_safe_builtin_call('re.compile') is True
    
    def test_dangerous_exec_not_safe(self):
        """exec is NOT safe builtin."""
        detector = AgentBoundaryDetector()
        assert detector.is_safe_builtin_call('exec') is False
        assert detector.is_safe_builtin_call('eval') is False


class TestAgent018Filtering:
    """Test AGENT-018 Python builtin filtering."""
    
    def test_python_set_is_builtin(self):
        """Python set() is builtin."""
        node = ast.parse("x = set([1, 2, 3])").body[0].value
        
        detector = AgentBoundaryDetector()
        is_builtin, reason = detector.is_python_builtin_collection(node)
        
        assert is_builtin is True
    
    def test_visited_add_is_builtin(self):
        """visited.add() is builtin tracking set."""
        node = ast.parse("visited.add(item)").body[0].value
        
        detector = AgentBoundaryDetector()
        is_builtin, reason = detector.is_python_builtin_collection(node, var_name='visited')
        
        assert is_builtin is True
    
    def test_memory_add_is_agent_memory(self):
        """memory.add() is Agent memory."""
        node = ast.parse("memory.add(message)").body[0].value
        
        detector = AgentBoundaryDetector()
        is_memory, reason = detector.is_agent_memory_operation(node, var_name='memory')
        
        assert is_memory is True


class TestShouldCheckFunctions:
    """Test decision functions."""
    
    def test_agent_034_requires_imports(self):
        """AGENT-034 requires Agent imports."""
        should_check, reason = should_check_agent_034(
            func_name="my_tool",
            has_agent_imports=False,
            is_tool_function=True,
        )
        assert should_check is False
    
    def test_agent_034_requires_tool_decorator(self):
        """AGENT-034 requires @tool decorator."""
        should_check, reason = should_check_agent_034(
            func_name="my_function",
            has_agent_imports=True,
            is_tool_function=False,
        )
        assert should_check is False
    
    def test_agent_034_skips_asyncio_run(self):
        """AGENT-034 skips asyncio.run."""
        should_check, reason = should_check_agent_034(
            func_name="my_tool",
            has_agent_imports=True,
            is_tool_function=True,
            call_name="asyncio.run",
        )
        assert should_check is False
```

### Phase 5: 验证与测试

#### 运行单元测试

```bash
cd packages/audit
poetry run pytest tests/test_analysis/test_agent_boundary_detector.py -v
```

#### 运行完整测试套件

```bash
poetry run pytest tests/ -v --tb=short
```

#### 运行 Benchmark 验证

```bash
cd tests/benchmark
python run_benchmark.py
```

预期结果:
- SWE-agent: 54 → ≤25 (AGENT-034: 33 → ≤6)
- Generative Agents: 11 → 0 (AGENT-018: 11 → 0)
- OWASP 覆盖: 10/10 (不变)

### Phase 6: 更新版本

```bash
# packages/audit/agent_audit/version.py
__version__ = "0.10.0"

# packages/audit/pyproject.toml
version = "0.10.0"
```

---

## 关键实施要点

### 必须遵守

1. **不要删除现有功能** - 只是添加前置过滤条件
2. **保持现有 API 兼容** - 不修改公共接口
3. **保留所有真阳性** - AGENT-044 (sudoers), AGENT-001 (command injection) 等必须继续工作
4. **类型注解完整** - 所有新函数必须有类型注解
5. **测试覆盖** - 新代码必须有单元测试

### 代码风格

- 遵循项目现有的 black/ruff 配置
- 使用 `from __future__ import annotations`
- Docstring 使用 Google 风格

### 测试验证

每次修改后运行:
```bash
# 快速验证
poetry run pytest tests/test_analysis/ -v

# 完整验证
poetry run pytest tests/ -v --tb=short
```

---

## 预期收益总结

| 指标 | v0.9.0 | v0.10.0 目标 | 变化 |
|------|--------|-------------|------|
| SWE-agent 总计 | 54 | ≤25 | -54% |
| SWE-agent AGENT-034 | 33 | ≤6 | -82% |
| Generative Agents | 11 | 0 | -100% |
| OWASP 覆盖 | 10/10 | 10/10 | 保持 |

---

**开始实施后，请按 Phase 顺序执行，每个 Phase 完成后运行测试验证。**
