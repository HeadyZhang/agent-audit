# Agent-Audit v0.12.0 语义层精细化技术规范

**版本**: v0.12.0  
**状态**: 待实施  
**前置**: v0.11.0 语义层基础已完成

---

## 1. 问题陈述

v0.11.0 实现了正确的语义层方向，但存在两个边界问题：

### 问题 1: `insert` 方法歧义

| 场景 | 当前行为 | 正确行为 |
|------|---------|---------|
| `list.insert(0, item)` | 触发 AGENT-018 ❌ | 不触发 |
| `index.insert(document)` (LlamaIndex) | 触发 AGENT-018 ✓ | 触发 |

**原因**: `is_agent_memory_method('insert')` 只检查方法名，不检查文件是否 import 了 llama_index。

### 问题 2: 无框架项目漏检

| 场景 | 当前行为 | 正确行为 |
|------|---------|---------|
| `@tool def shell(cmd): subprocess.run(cmd)` | 触发 AGENT-034 ✓ | 触发 |
| OpenAI function calling + `eval(code)` | 不触发 ❌ | 应该触发 |

**原因**: `is_tool_entry_point()` 只识别 @tool 装饰器和 Tool 基类，不识别 OpenAI function calling 模式。

---

## 2. 解决方案

### 2.1 问题 1: 带 Import 检查的方法白名单

**核心思路**: 对有歧义的方法（如 `insert`），增加 import 上下文检查。

```python
# 有歧义的方法 - 需要检查 import
AMBIGUOUS_METHODS: Dict[str, Set[str]] = {
    'insert': {'llama_index'},           # 只有 import llama_index 时才触发
    'upsert': {'pinecone', 'chromadb', 'weaviate'},  # 向量数据库
}

def is_agent_memory_method(
    method_name: str,
    file_imports: Optional[Set[str]] = None,  # 新增参数
) -> Tuple[bool, str]:
    """
    检查方法是否为 Agent 内存操作。
    
    对于有歧义的方法，需要检查 file_imports。
    """
    if method_name not in AGENT_MEMORY_WRITE_METHODS:
        return (False, "")
    
    framework = AGENT_MEMORY_WRITE_METHODS[method_name]
    
    # 检查是否需要 import 验证
    if method_name in AMBIGUOUS_METHODS:
        required_imports = AMBIGUOUS_METHODS[method_name]
        if file_imports:
            # 检查是否有匹配的 import
            imports_lower = {imp.lower() for imp in file_imports}
            if not any(req in imp for req in required_imports for imp in imports_lower):
                return (False, "")  # 没有对应 import，跳过
    
    return (True, framework)
```

### 2.2 问题 2: 扩展 Tool 入口识别

**核心思路**: 识别 OpenAI function calling 模式的函数。

```python
# OpenAI Function Calling 识别模式
OPENAI_FUNCTION_INDICATORS = [
    # 装饰器模式
    '@function_schema',
    '@openai_function', 
    '@tool_function',
    
    # 函数被传给 tools 参数
    # tools=[func1, func2]
    # functions=[{"name": "xxx", ...}]
]

# OpenAI/Anthropic API 调用模式
FUNCTION_CALLING_API_CALLS: Set[str] = {
    'chat.completions.create',
    'ChatCompletion.create', 
    'messages.create',
    'client.chat.completions.create',
}

def is_tool_entry_point(
    node: ast.FunctionDef,
    parent_class: Optional[str] = None,
    parent_bases: Optional[Set[str]] = None,
    file_context: Optional[FileToolContext] = None,  # 新增
) -> ToolBoundaryResult:
    """
    扩展 Tool 入口识别。
    
    新增：识别 OpenAI function calling 模式
    """
    # 原有检查 1-3 ...
    
    # Check 4: OpenAI function calling 模式
    if file_context and file_context.is_function_calling_context:
        # 函数名在 tools 列表中
        if node.name in file_context.registered_tool_functions:
            return ToolBoundaryResult(
                is_tool_entry=True,
                reason=f"OpenAI function calling: {node.name}",
                confidence=0.85,
                tool_type='openai_function'
            )
    
    return ToolBoundaryResult(is_tool_entry=False, ...)
```

---

## 3. 实现规范

### 3.1 修改 memory_method_detector.py

```python
"""v0.12.0: 带 Import 检查的方法白名单"""

from __future__ import annotations
from typing import Dict, Tuple, Optional, Set

# 无歧义的方法 - 直接触发
UNAMBIGUOUS_MEMORY_METHODS: Dict[str, str] = {
    'add_message': 'langchain',
    'add_user_message': 'langchain',
    'add_ai_message': 'langchain',
    'add_messages': 'langchain',
    'save_context': 'langchain',
    'add_memory': 'langchain',
    'add_texts': 'vector_store',
    'add_documents': 'vector_store',
    'aadd_texts': 'vector_store',
    'aadd_documents': 'vector_store',
    'insert_nodes': 'llama_index',
    'add_to_memory': 'crewai',
    'write_documents': 'haystack',
    'store_memory': 'generic',
    'persist_memory': 'generic',
    'save_memory': 'generic',
    'update_memory': 'generic',
    'update_context': 'generic',
}

# 有歧义的方法 - 需要检查 import
AMBIGUOUS_MEMORY_METHODS: Dict[str, Tuple[str, Set[str]]] = {
    # method_name: (framework, required_import_keywords)
    'insert': ('llama_index', {'llama_index', 'llama-index'}),
    'upsert': ('vector_store', {'pinecone', 'chromadb', 'weaviate', 'qdrant', 'milvus'}),
}


def is_agent_memory_method(
    method_name: str,
    file_imports: Optional[Set[str]] = None,
) -> Tuple[bool, str]:
    """
    检查方法是否为 Agent 内存操作。
    
    v0.12.0: 对有歧义的方法增加 import 检查。
    
    Args:
        method_name: 方法名
        file_imports: 文件的 import 列表 (用于歧义方法检查)
    
    Returns:
        (is_memory_method, framework)
    """
    # 检查无歧义方法
    if method_name in UNAMBIGUOUS_MEMORY_METHODS:
        return (True, UNAMBIGUOUS_MEMORY_METHODS[method_name])
    
    # 检查有歧义方法
    if method_name in AMBIGUOUS_MEMORY_METHODS:
        framework, required_imports = AMBIGUOUS_MEMORY_METHODS[method_name]
        
        # 没有 import 信息时，保守处理：触发检测
        if file_imports is None:
            return (True, framework)
        
        # 检查是否有匹配的 import
        imports_str = ' '.join(file_imports).lower()
        if any(req in imports_str for req in required_imports):
            return (True, framework)
        
        # 没有对应 import，这可能是 Python 内置操作
        return (False, "")
    
    return (False, "")


def _normalize_imports(imports: Set[str]) -> str:
    """将 import 列表转为小写字符串用于匹配"""
    return ' '.join(imports).lower().replace('-', '_')
```

### 3.2 修改 python_scanner.py 中的调用

```python
def _check_memory_poisoning(self, node: ast.Call) -> Optional[Dict[str, Any]]:
    """AGENT-018: 检测 Agent 内存写入"""
    
    # ... 现有代码 ...
    
    method_name = func_name.split('.')[-1] if '.' in func_name else func_name
    
    # === v0.12.0: 传入 imports 用于歧义方法检查 ===
    is_memory, framework = is_agent_memory_method(
        method_name,
        file_imports=set(self.imports),  # 新增参数
    )
    if not is_memory:
        return None
    
    # ... 后续代码 ...
```

### 3.3 扩展 tool_boundary_detector.py

```python
"""v0.12.0: 扩展 Tool 入口识别"""

from __future__ import annotations
import ast
from dataclasses import dataclass, field
from typing import Optional, Set, List

# ... 原有代码 ...

# OpenAI Function Calling 装饰器
FUNCTION_CALLING_DECORATORS: Set[str] = {
    'function_schema',
    'openai_function',
    'tool_function',
    'function_def',
}

# Function Calling API 调用
FUNCTION_CALLING_API: Set[str] = {
    'chat.completions.create',
    'ChatCompletion.create',
    'messages.create',
    'completions.create',
}


@dataclass
class FileToolContext:
    """文件级 Tool 上下文"""
    has_openai_import: bool = False
    has_anthropic_import: bool = False
    has_function_calling_api: bool = False
    registered_tool_functions: Set[str] = field(default_factory=set)


def analyze_file_tool_context(tree: ast.AST, imports: Set[str]) -> FileToolContext:
    """
    分析文件的 Tool 上下文。
    
    识别 OpenAI function calling 模式。
    """
    ctx = FileToolContext()
    
    # 检查 OpenAI/Anthropic import
    imports_str = ' '.join(imports).lower()
    ctx.has_openai_import = 'openai' in imports_str
    ctx.has_anthropic_import = 'anthropic' in imports_str
    
    # 遍历 AST 查找 function calling API 调用
    for node in ast.walk(tree):
        if isinstance(node, ast.Call):
            call_name = _get_call_name_from_node(node)
            if call_name:
                # 检查是否调用了 function calling API
                if any(api in call_name for api in FUNCTION_CALLING_API):
                    ctx.has_function_calling_api = True
                    # 提取 tools/functions 参数中的函数名
                    _extract_tool_functions(node, ctx)
    
    return ctx


def _extract_tool_functions(call_node: ast.Call, ctx: FileToolContext):
    """从 API 调用中提取注册的 tool 函数名"""
    for keyword in call_node.keywords:
        if keyword.arg in ('tools', 'functions'):
            # tools=[func1, func2, ...]
            if isinstance(keyword.value, ast.List):
                for elt in keyword.value.elts:
                    if isinstance(elt, ast.Name):
                        ctx.registered_tool_functions.add(elt.id)
                    elif isinstance(elt, ast.Dict):
                        # {"name": "func_name", ...}
                        for key, val in zip(elt.keys, elt.values):
                            if isinstance(key, ast.Constant) and key.value == 'name':
                                if isinstance(val, ast.Constant):
                                    ctx.registered_tool_functions.add(val.value)


def is_tool_entry_point(
    node: ast.FunctionDef,
    parent_class: Optional[str] = None,
    parent_bases: Optional[Set[str]] = None,
    file_context: Optional[FileToolContext] = None,
) -> ToolBoundaryResult:
    """
    检查函数是否为 Tool 入口点。
    
    v0.12.0: 新增 OpenAI function calling 识别。
    """
    # Check 1: @tool 装饰器
    for decorator in node.decorator_list:
        dec_name = _get_decorator_name(decorator)
        if dec_name in TOOL_DECORATORS:
            return ToolBoundaryResult(
                is_tool_entry=True,
                reason=f"@{dec_name} decorator",
                confidence=0.95,
                tool_type='decorator'
            )
        # v0.12.0: function calling 装饰器
        if dec_name in FUNCTION_CALLING_DECORATORS:
            return ToolBoundaryResult(
                is_tool_entry=True,
                reason=f"@{dec_name} function calling decorator",
                confidence=0.90,
                tool_type='function_calling_decorator'
            )
    
    # Check 2: Tool 类方法
    if parent_class and parent_bases:
        if node.name in TOOL_CLASS_METHODS:
            if parent_bases & TOOL_BASE_CLASSES:
                return ToolBoundaryResult(
                    is_tool_entry=True,
                    reason=f"{parent_class}.{node.name}() in Tool class",
                    confidence=0.90,
                    tool_type='class_method'
                )
    
    # Check 3: 函数名 heuristic
    if 'tool' in node.name.lower():
        if _has_str_params(node):
            return ToolBoundaryResult(
                is_tool_entry=True,
                reason=f"Name heuristic: {node.name}",
                confidence=0.60,
                tool_type='name_heuristic'
            )
    
    # Check 4: OpenAI function calling 模式 (v0.12.0)
    if file_context and file_context.has_function_calling_api:
        if node.name in file_context.registered_tool_functions:
            return ToolBoundaryResult(
                is_tool_entry=True,
                reason=f"OpenAI function calling: {node.name}",
                confidence=0.85,
                tool_type='openai_function'
            )
    
    # NOT a Tool entry point
    return ToolBoundaryResult(
        is_tool_entry=False,
        reason="Not a Tool entry point",
        confidence=0.0,
        tool_type=None
    )


def _get_call_name_from_node(node: ast.Call) -> Optional[str]:
    """从 Call 节点提取函数名"""
    if isinstance(node.func, ast.Name):
        return node.func.id
    elif isinstance(node.func, ast.Attribute):
        parts = []
        current = node.func
        while isinstance(current, ast.Attribute):
            parts.append(current.attr)
            current = current.value
        if isinstance(current, ast.Name):
            parts.append(current.id)
        parts.reverse()
        return '.'.join(parts)
    return None
```

### 3.4 修改 python_scanner.py 中的 Tool 检测

```python
class PythonScanner:
    def __init__(self, ...):
        # ... 原有代码 ...
        self._file_tool_context: Optional[FileToolContext] = None
    
    def visit_Module(self, node: ast.Module):
        """模块入口 - 分析文件级上下文"""
        # v0.12.0: 分析 function calling 上下文
        self._file_tool_context = analyze_file_tool_context(
            node, 
            set(self.imports)
        )
        self.generic_visit(node)
    
    def _check_tool_no_input_validation(self, node: ast.FunctionDef):
        """AGENT-034: Tool 输入验证检测"""
        
        # === v0.12.0: 传入 file_context ===
        boundary = is_tool_entry_point(
            node,
            parent_class=self._current_class,
            parent_bases=getattr(self, '_current_class_bases', None),
            file_context=self._file_tool_context,  # 新增
        )
        
        if not boundary.is_tool_entry:
            return None
        
        # ... 后续代码 ...
```

---

## 4. 测试用例

### 4.1 insert 方法测试

```python
def test_insert_without_llama_index_import():
    """list.insert() 不应触发"""
    source = '''
my_list = []
my_list.insert(0, item)
'''
    # imports 不包含 llama_index
    is_mem, _ = is_agent_memory_method('insert', file_imports={'os', 'sys'})
    assert is_mem is False


def test_insert_with_llama_index_import():
    """llama_index index.insert() 应该触发"""
    source = '''
from llama_index import VectorStoreIndex
index = VectorStoreIndex()
index.insert(document)
'''
    is_mem, framework = is_agent_memory_method('insert', file_imports={'llama_index'})
    assert is_mem is True
    assert framework == 'llama_index'
```

### 4.2 OpenAI function calling 测试

```python
def test_openai_function_calling_detection():
    """OpenAI function calling 函数应该被识别为 Tool 入口"""
    source = '''
import openai

def get_weather(location: str) -> str:
    return f"Weather in {location}"

response = client.chat.completions.create(
    model="gpt-4",
    tools=[get_weather],
)
'''
    tree = ast.parse(source)
    ctx = analyze_file_tool_context(tree, {'openai'})
    
    assert ctx.has_openai_import is True
    assert ctx.has_function_calling_api is True
    assert 'get_weather' in ctx.registered_tool_functions
    
    # get_weather 函数应该被识别为 Tool 入口
    func_node = tree.body[1]  # def get_weather
    result = is_tool_entry_point(func_node, file_context=ctx)
    assert result.is_tool_entry is True
    assert result.tool_type == 'openai_function'
```

---

## 5. 预期效果

| 场景 | v0.11.0 | v0.12.0 |
|------|---------|---------|
| `list.insert(0, item)` | 触发 AGENT-018 ❌ | 不触发 ✓ |
| `index.insert(doc)` (有 llama_index import) | 触发 ✓ | 触发 ✓ |
| OpenAI function + eval | 不触发 ❌ | 触发 ✓ |
| @tool + subprocess | 触发 ✓ | 触发 ✓ |

---

## 6. 实施顺序

1. **Phase 1**: 修复 `insert` 歧义问题 (简单，低风险)
   - 修改 `memory_method_detector.py`
   - 修改 `python_scanner.py` 传入 imports
   - 添加测试

2. **Phase 2**: 扩展 OpenAI function calling 识别 (中等复杂度)
   - 添加 `FileToolContext` 和分析函数
   - 修改 `is_tool_entry_point()` 
   - 修改 `python_scanner.py` 分析文件上下文
   - 添加测试

---

## 7. 回滚策略

两个修改相互独立，可以单独回滚：

```python
# 如果 insert 修复有问题，回滚到只检查方法名
def is_agent_memory_method(method_name: str, file_imports=None):
    # 忽略 file_imports 参数
    if method_name in AGENT_MEMORY_WRITE_METHODS:
        return (True, AGENT_MEMORY_WRITE_METHODS[method_name])
    return (False, "")

# 如果 function calling 识别有问题，回滚到不传 file_context
boundary = is_tool_entry_point(node, parent_class, parent_bases)
# 删除 file_context 参数
```
