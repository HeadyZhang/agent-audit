# Agent-Audit v0.10.0 语义层重构技术规范

**版本**: v0.10.0  
**状态**: 待实施  
**优先级**: P0 (Critical)  
**预期收益**: SWE-agent 54→20, Generative Agents 11→0

---

## 1. 问题陈述

### 1.1 核心问题

当前 AGENT-034 和 AGENT-018 规则基于**语法模式**触发，没有考虑代码的**语义上下文**——即代码是否真正处于 Agent 执行边界内。

| 规则 | 当前逻辑 | 问题 | FP 实例 |
|------|---------|------|---------|
| AGENT-034 | `@tool + str参数 + dangerous_op` | 普通 Python 代码也触发 | `asyncio.run()`, `re.compile()` |
| AGENT-018 | `method.name in MEMORY_WRITE_FUNCTIONS` | Python 内置操作也触发 | `set()`, `list.append()` |

### 1.2 数据佐证

```
SWE-agent v0.9.0:
  - AGENT-034: 33 findings (目标 ~6, 差距 27 FP)
  - 典型 FP: asyncio.run(main()), re.compile(pattern)
  
Generative Agents v0.9.0:
  - AGENT-018: 11 findings (目标 0, 全部是 FP)
  - 全部是 Python set() 操作: set([a, b, c])
```

### 1.3 根因分析

```
┌─────────────────────────────────────────────────────────────────┐
│  当前检测流程 (有缺陷)                                            │
├─────────────────────────────────────────────────────────────────┤
│  File → Parse AST → Match Syntax Pattern → Report Finding       │
│                                                                 │
│  问题: 没有 "是否在 Agent 上下文中" 的检查                         │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  优化后检测流程                                                   │
├─────────────────────────────────────────────────────────────────┤
│  File → Parse AST → Check Agent Context → Match Pattern → Report│
│                     ↑                                           │
│              新增语义层检查                                       │
└─────────────────────────────────────────────────────────────────┘
```

---

## 2. 解决方案设计

### 2.1 核心概念: Agent 边界检测器

创建 `AgentBoundaryDetector` 类，在规则检测之前判断代码是否在 Agent 执行上下文中。

```
Agent 上下文层级:
├── Level 1: File Context (文件级)
│   └── 文件是否 import 了 Agent 框架?
├── Level 2: Class Context (类级)
│   └── 当前类是否继承 Agent/Tool 基类?
├── Level 3: Function Context (函数级)
│   └── 函数是否有 @tool 装饰器?
└── Level 4: Call Context (调用级)
    └── 被调用的方法是否属于 Agent 对象?
```

### 2.2 AGENT-034 修复策略

**问题**: `asyncio.run()` 和 `re.compile()` 等被误报

**原因分析**:
```python
# 当前 dangerous_operation_analyzer.py 的 DANGEROUS_FUNCTIONS 包含:
'subprocess.run': (DangerousOperationType.SHELL_EXECUTION, 0.90),
'os.system': (DangerousOperationType.SHELL_EXECUTION, 0.95),
...

# 但没有排除安全的 Python 内置操作:
# - asyncio.run() - 只是异步执行，不是危险操作
# - re.compile() - 只是编译正则，不是代码执行
```

**解决方案**:

1. 添加 **Safe Builtin Functions** 排除列表
2. 区分 **真正的代码执行** vs **普通函数调用**
3. 只在 **Agent 边界内** 触发检测

### 2.3 AGENT-018 修复策略

**问题**: Python `set()` 被误判为 Agent memory write

**原因分析**:
```python
# 当前 MEMORY_WRITE_FUNCTIONS 包含:
WRITE_OPERATIONS: Set[str] = {
    'append', 'add', 'save', 'store', 'put', 'set', 'update',  # ← 'add' 和 'set' 太宽泛
    ...
}

# Python 内置的 set() 调用也会匹配:
my_set = set([a, b, c])  # 被误报为 AGENT-018
```

**解决方案**:

1. 检查调用者对象类型，区分 `memory.add()` vs `set.add()`
2. 添加 **Python Builtin** 排除列表
3. 要求调用者对象名称包含 memory/store/db 关键词

---

## 3. 实现规范

### 3.1 新增文件: `agent_boundary_detector.py`

**位置**: `packages/audit/agent_audit/analysis/agent_boundary_detector.py`

```python
"""
Agent Boundary Detection for Semantic-Layer False Positive Reduction.

This module determines if code is within an Agent execution boundary,
which is required for AGENT-034/018 rules to fire.

Agent Context Hierarchy:
1. File Context - Does file import Agent frameworks?
2. Class Context - Is class an Agent/Tool subclass?  
3. Function Context - Does function have @tool decorator?
4. Call Context - Is method called on an Agent object?
"""

from __future__ import annotations

import ast
import re
from dataclasses import dataclass, field
from enum import Enum
from typing import Dict, List, Optional, Set, Tuple


class AgentContextLevel(Enum):
    """Level of Agent context detection."""
    NONE = "none"           # Not in Agent context
    FILE = "file"           # File imports Agent framework
    CLASS = "class"         # Inside Agent/Tool class
    FUNCTION = "function"   # Inside @tool decorated function
    CALL = "call"           # Method called on Agent object


@dataclass
class AgentBoundaryResult:
    """Result of Agent boundary detection."""
    is_agent_context: bool
    context_level: AgentContextLevel
    framework_detected: Optional[str] = None
    confidence: float = 0.0
    reason: str = ""
    # Additional context
    in_tool_function: bool = False
    in_agent_class: bool = False
    has_agent_imports: bool = False


# ============================================================
# AGENT FRAMEWORK IMPORTS
# ============================================================

AGENT_FRAMEWORK_IMPORTS: Dict[str, List[str]] = {
    'langchain': [
        'langchain',
        'langchain_core',
        'langchain_community', 
        'langchain_openai',
        'langchain_anthropic',
    ],
    'crewai': [
        'crewai',
    ],
    'autogen': [
        'autogen',
        'pyautogen',
    ],
    'openai_agents': [
        'agents',  # OpenAI Agents SDK
    ],
    'llama_index': [
        'llama_index',
    ],
    'haystack': [
        'haystack',
    ],
    'semantic_kernel': [
        'semantic_kernel',
    ],
    'google_adk': [
        'google.adk',
        'google.generativeai',
    ],
}

# Flattened list for quick lookup
ALL_AGENT_IMPORTS: Set[str] = set()
for imports in AGENT_FRAMEWORK_IMPORTS.values():
    ALL_AGENT_IMPORTS.update(imports)


# ============================================================
# AGENT/TOOL BASE CLASSES
# ============================================================

AGENT_BASE_CLASSES: Set[str] = {
    # LangChain
    'BaseTool', 'Tool', 'StructuredTool',
    'BaseAgent', 'Agent', 'AgentExecutor',
    'BaseRetriever', 'BaseMemory',
    'RunnableLambda', 'RunnableSequence',
    # CrewAI
    'Agent', 'Task', 'Crew', 'Process',
    # AutoGen
    'AssistantAgent', 'UserProxyAgent', 'ConversableAgent',
    'GroupChat', 'GroupChatManager',
    # LlamaIndex
    'QueryEngine', 'BaseTool', 'FunctionTool',
    # Generic patterns
    'BaseAgent', 'BaseTool', 'BaseMemory',
}

TOOL_DECORATORS: Set[str] = {
    'tool',           # LangChain @tool
    'function_tool',  # LlamaIndex
    'kernel_function', # Semantic Kernel
}


# ============================================================
# SAFE BUILTIN OPERATIONS (Not dangerous even in Agent context)
# ============================================================

# These are safe Python operations that should NEVER trigger AGENT-034
# even when called with user-controlled strings
SAFE_BUILTIN_CALLS: Set[str] = {
    # Async operations (not code execution)
    'asyncio.run',
    'asyncio.create_task',
    'asyncio.gather',
    'asyncio.wait',
    'asyncio.sleep',
    # Regex operations (pattern matching, not code execution)
    're.compile',
    're.match',
    're.search', 
    're.findall',
    're.sub',
    're.split',
    # String operations
    'str.format',
    'str.replace',
    'str.split',
    'str.join',
    # JSON operations (parsing, not execution)
    'json.loads',
    'json.dumps',
    'json.load',
    'json.dump',
    # Type operations
    'type',
    'isinstance',
    'issubclass',
    'hasattr',
    'getattr',
    'setattr',
    # Collection operations
    'list',
    'dict',
    'set',
    'tuple',
    'frozenset',
    'len',
    'sorted',
    'reversed',
    'enumerate',
    'zip',
    'map',
    'filter',
    # Math operations
    'int',
    'float',
    'abs',
    'min',
    'max',
    'sum',
    'round',
    # Path operations (reading, not execution)
    'pathlib.Path',
    'os.path.join',
    'os.path.exists',
    'os.path.dirname',
    'os.path.basename',
    # Logging
    'logging.info',
    'logging.debug',
    'logging.warning',
    'logging.error',
    'print',
}


# ============================================================
# PYTHON BUILTIN TYPES (Not Agent memory)
# ============================================================

# These Python builtins should NOT trigger AGENT-018
# Their .add() / .append() methods are NOT memory poisoning
PYTHON_BUILTIN_TYPES: Set[str] = {
    'set',
    'frozenset',
    'list',
    'dict',
    'collections.deque',
    'collections.OrderedDict',
    'collections.defaultdict',
    'queue.Queue',
    'queue.PriorityQueue',
}

# Variable name patterns that indicate Python builtins, not Agent memory
BUILTIN_VARIABLE_PATTERNS: List[re.Pattern] = [
    re.compile(r'^_?(?:seen|visited|processed|checked|done|used)_?\w*$', re.I),
    re.compile(r'^_?(?:temp|tmp|local|internal)_?\w*$', re.I),
    re.compile(r'^_?(?:ids|keys|values|items|names|tags|labels)$', re.I),
    re.compile(r'^_?\w*(?:_set|_list|_dict|_queue|_stack)$', re.I),
]


# ============================================================
# AGENT MEMORY INDICATORS
# ============================================================

# Variable/attribute names that indicate Agent memory operations
AGENT_MEMORY_INDICATORS: List[re.Pattern] = [
    re.compile(r'memory', re.I),
    re.compile(r'store', re.I),
    re.compile(r'vector', re.I),
    re.compile(r'embed', re.I),
    re.compile(r'retriev', re.I),
    re.compile(r'context', re.I),
    re.compile(r'history', re.I),
    re.compile(r'conversation', re.I),
    re.compile(r'message', re.I),
    re.compile(r'chat', re.I),
    re.compile(r'db', re.I),
    re.compile(r'database', re.I),
    re.compile(r'persist', re.I),
    re.compile(r'cache', re.I),
]


class AgentBoundaryDetector:
    """
    Detects whether code is within an Agent execution boundary.
    
    Used to prevent false positives for AGENT-034/018 rules
    when code is not actually in Agent context.
    """
    
    def __init__(self):
        self._file_imports: Set[str] = set()
        self._detected_framework: Optional[str] = None
        self._class_stack: List[str] = []
        self._function_stack: List[Tuple[str, bool]] = []  # (name, is_tool)
    
    def analyze_file(self, source: str) -> AgentBoundaryResult:
        """
        Analyze a file to determine if it contains Agent code.
        
        Returns file-level Agent context.
        """
        try:
            tree = ast.parse(source)
        except SyntaxError:
            return AgentBoundaryResult(
                is_agent_context=False,
                context_level=AgentContextLevel.NONE,
                reason="Failed to parse file"
            )
        
        # Extract imports
        self._file_imports = self._extract_imports(tree)
        self._detected_framework = self._detect_framework(self._file_imports)
        
        has_agent_imports = self._detected_framework is not None
        
        return AgentBoundaryResult(
            is_agent_context=has_agent_imports,
            context_level=AgentContextLevel.FILE if has_agent_imports else AgentContextLevel.NONE,
            framework_detected=self._detected_framework,
            confidence=0.7 if has_agent_imports else 0.0,
            reason=f"Framework detected: {self._detected_framework}" if has_agent_imports else "No Agent framework imports",
            has_agent_imports=has_agent_imports,
        )
    
    def _extract_imports(self, tree: ast.AST) -> Set[str]:
        """Extract all import statements from AST."""
        imports = set()
        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for alias in node.names:
                    imports.add(alias.name.split('.')[0])
            elif isinstance(node, ast.ImportFrom):
                if node.module:
                    imports.add(node.module.split('.')[0])
        return imports
    
    def _detect_framework(self, imports: Set[str]) -> Optional[str]:
        """Detect Agent framework from imports."""
        for framework, modules in AGENT_FRAMEWORK_IMPORTS.items():
            for module in modules:
                module_base = module.split('.')[0]
                if module_base in imports:
                    return framework
        return None
    
    def is_in_tool_function(
        self,
        node: ast.FunctionDef,
    ) -> bool:
        """
        Check if a function is a tool function (has @tool decorator).
        """
        for decorator in node.decorator_list:
            dec_name = self._get_decorator_name(decorator)
            if dec_name in TOOL_DECORATORS:
                return True
        return False
    
    def _get_decorator_name(self, decorator: ast.expr) -> str:
        """Get the name of a decorator."""
        if isinstance(decorator, ast.Name):
            return decorator.id
        elif isinstance(decorator, ast.Attribute):
            return decorator.attr
        elif isinstance(decorator, ast.Call):
            return self._get_decorator_name(decorator.func)
        return ""
    
    def is_in_agent_class(
        self,
        node: ast.ClassDef,
    ) -> bool:
        """
        Check if a class inherits from Agent/Tool base classes.
        """
        for base in node.bases:
            base_name = self._get_base_name(base)
            if base_name in AGENT_BASE_CLASSES:
                return True
        return False
    
    def _get_base_name(self, node: ast.expr) -> str:
        """Get the name of a base class."""
        if isinstance(node, ast.Name):
            return node.id
        elif isinstance(node, ast.Attribute):
            return node.attr
        return ""
    
    def is_safe_builtin_call(self, func_name: str) -> bool:
        """
        Check if a function call is a safe Python builtin.
        
        Safe builtins should NOT trigger AGENT-034 even in Agent context.
        """
        # Direct match
        if func_name in SAFE_BUILTIN_CALLS:
            return True
        
        # Check if it's a method on a safe module
        parts = func_name.split('.')
        if len(parts) >= 2:
            module = parts[0]
            if module in {'asyncio', 're', 'json', 'logging', 'pathlib'}:
                return True
        
        return False
    
    def is_python_builtin_collection(
        self,
        node: ast.Call,
        var_name: Optional[str] = None,
    ) -> Tuple[bool, str]:
        """
        Check if a call is on a Python builtin collection (set/list/dict).
        
        Returns (is_builtin, reason).
        Used to filter out AGENT-018 false positives.
        """
        func_name = self._get_call_name(node)
        if not func_name:
            return (False, "")
        
        # Check if it's a builtin type constructor
        if func_name in PYTHON_BUILTIN_TYPES:
            return (True, f"Python builtin: {func_name}()")
        
        # Check if it's a method call on a builtin
        if '.' in func_name:
            parts = func_name.split('.')
            obj_name = parts[0]
            method_name = parts[-1]
            
            # Check if object name matches builtin patterns
            for pattern in BUILTIN_VARIABLE_PATTERNS:
                if pattern.match(obj_name):
                    return (True, f"Builtin collection variable: {obj_name}")
        
        # If var_name provided, check it too
        if var_name:
            for pattern in BUILTIN_VARIABLE_PATTERNS:
                if pattern.match(var_name):
                    return (True, f"Builtin collection variable: {var_name}")
        
        return (False, "")
    
    def is_agent_memory_operation(
        self,
        node: ast.Call,
        var_name: Optional[str] = None,
    ) -> Tuple[bool, str]:
        """
        Check if a call is an Agent memory operation.
        
        Returns (is_memory_op, reason).
        Used for AGENT-018 to distinguish real memory ops from builtins.
        """
        # First check if it's NOT a builtin
        is_builtin, _ = self.is_python_builtin_collection(node, var_name)
        if is_builtin:
            return (False, "Python builtin, not Agent memory")
        
        func_name = self._get_call_name(node)
        if not func_name:
            return (False, "Unknown function")
        
        # Check if the object name indicates Agent memory
        if '.' in func_name:
            parts = func_name.split('.')
            obj_name = parts[0]
            
            for pattern in AGENT_MEMORY_INDICATORS:
                if pattern.search(obj_name):
                    return (True, f"Agent memory indicator: {obj_name}")
        
        # Check var_name if provided
        if var_name:
            for pattern in AGENT_MEMORY_INDICATORS:
                if pattern.search(var_name):
                    return (True, f"Agent memory indicator: {var_name}")
        
        return (False, "No Agent memory indicators")
    
    def _get_call_name(self, node: ast.Call) -> Optional[str]:
        """Get the full name of a function call."""
        if isinstance(node.func, ast.Name):
            return node.func.id
        elif isinstance(node.func, ast.Attribute):
            parts = []
            current = node.func
            while isinstance(current, ast.Attribute):
                parts.append(current.attr)
                current = current.value
            if isinstance(current, ast.Name):
                parts.append(current.id)
            parts.reverse()
            return '.'.join(parts)
        return None


def should_check_agent_034(
    func_name: str,
    has_agent_imports: bool,
    is_tool_function: bool,
    call_name: Optional[str] = None,
) -> Tuple[bool, str]:
    """
    Determine if AGENT-034 check should be performed.
    
    Args:
        func_name: Name of the function being analyzed
        has_agent_imports: Whether file has Agent framework imports
        is_tool_function: Whether function has @tool decorator
        call_name: Name of the dangerous call being checked
    
    Returns:
        (should_check, reason)
    """
    detector = AgentBoundaryDetector()
    
    # Requirement 1: Must have Agent imports
    if not has_agent_imports:
        return (False, "No Agent framework imports in file")
    
    # Requirement 2: Must be in @tool function
    if not is_tool_function:
        return (False, "Function does not have @tool decorator")
    
    # Requirement 3: Call must not be a safe builtin
    if call_name and detector.is_safe_builtin_call(call_name):
        return (False, f"Safe builtin call: {call_name}")
    
    return (True, "In Agent context with dangerous operation")


def should_check_agent_018(
    node: ast.Call,
    has_agent_imports: bool,
    var_name: Optional[str] = None,
) -> Tuple[bool, str]:
    """
    Determine if AGENT-018 check should be performed.
    
    Args:
        node: The AST Call node
        has_agent_imports: Whether file has Agent framework imports
        var_name: Variable name if assignment
    
    Returns:
        (should_check, reason)
    """
    detector = AgentBoundaryDetector()
    
    # Requirement 1: Must have Agent imports
    if not has_agent_imports:
        return (False, "No Agent framework imports in file")
    
    # Requirement 2: Must NOT be a Python builtin collection
    is_builtin, builtin_reason = detector.is_python_builtin_collection(node, var_name)
    if is_builtin:
        return (False, builtin_reason)
    
    # Requirement 3: Should be an Agent memory operation
    is_memory, memory_reason = detector.is_agent_memory_operation(node, var_name)
    if not is_memory:
        return (False, memory_reason)
    
    return (True, f"Agent memory operation: {memory_reason}")
```

### 3.2 修改: `python_scanner.py`

#### 3.2.1 添加文件级 Agent 上下文检测

在 `PythonScanner.__init__` 或 `scan` 方法开头:

```python
from agent_audit.analysis.agent_boundary_detector import (
    AgentBoundaryDetector,
    should_check_agent_034,
    should_check_agent_018,
)

class PythonScanner:
    def __init__(self, ...):
        # ... existing code ...
        self._agent_detector = AgentBoundaryDetector()
        self._has_agent_imports = False
        self._detected_framework = None
    
    def scan(self, file_path: Path, source: str) -> List[Finding]:
        # ... existing code ...
        
        # NEW: Analyze file for Agent context
        file_context = self._agent_detector.analyze_file(source)
        self._has_agent_imports = file_context.has_agent_imports
        self._detected_framework = file_context.framework_detected
        
        # ... rest of scan logic ...
```

#### 3.2.2 修改 `_check_tool_no_input_validation` (AGENT-034)

```python
def _check_tool_no_input_validation(
    self, node: ast.FunctionDef
) -> Optional[Dict[str, Any]]:
    """
    AGENT-034: Detect tool functions without input validation.
    
    v0.10.0: Only trigger in Agent context with dangerous operations.
    """
    # === NEW v0.10.0: Agent boundary check ===
    # Requirement 1: File must have Agent framework imports
    if not self._has_agent_imports:
        return None  # Not in Agent context
    
    # Check if it's a tool function
    is_tool = self._has_tool_decorator(node) or 'tool' in node.name.lower()
    
    # Requirement 2: Must be a @tool function
    if not is_tool:
        return None
    
    # ... existing parameter extraction code ...
    
    # v0.6.0: Use dangerous operation analyzer
    func_body = ast.get_source_segment(self.source, node) or ''
    
    should_flag, analyzer_confidence, reason = should_flag_tool_input(
        func_name=node.name,
        func_body=func_body,
        param_names=list(str_params),
        has_validation=False,
    )
    
    if not should_flag:
        return None
    
    # === NEW v0.10.0: Safe builtin check ===
    # Check if the "dangerous" operation is actually a safe builtin
    for call_node in ast.walk(node):
        if isinstance(call_node, ast.Call):
            call_name = self._get_call_name(call_node)
            if call_name and self._agent_detector.is_safe_builtin_call(call_name):
                # Skip - this is a safe builtin like asyncio.run()
                continue
    
    # ... rest of existing code ...
```

#### 3.2.3 修改 `_check_memory_poisoning` (AGENT-018)

```python
def _check_memory_poisoning(self, node: ast.Call) -> Optional[Dict[str, Any]]:
    """
    ASI-06: Detect unsanitized writes to vector databases or memory stores.
    
    v0.10.0: Only trigger for actual Agent memory operations,
             NOT Python builtins like set() or list.append().
    """
    # v0.3.2: Skip framework internal code and test files
    file_path = str(self.file_path) if self.file_path else ''
    if self._is_framework_internal_path(file_path):
        return None
    
    # === NEW v0.10.0: Agent boundary check ===
    # Requirement 1: File must have Agent framework imports
    if not self._has_agent_imports:
        return None  # Not in Agent context
    
    func_name = self._get_call_name(node)
    if not func_name:
        return None
    
    # Extract method name
    method_name = func_name.split('.')[-1] if '.' in func_name else func_name
    
    if method_name not in self.MEMORY_WRITE_FUNCTIONS:
        return None
    
    # === NEW v0.10.0: Python builtin filter ===
    # Check if this is a Python builtin collection operation
    is_builtin, builtin_reason = self._agent_detector.is_python_builtin_collection(
        node=node,
        var_name=self._extract_receiver_name(node),
    )
    if is_builtin:
        return None  # Skip Python builtins like set(), list.append()
    
    # === NEW v0.10.0: Agent memory indicator check ===
    # Check if this is actually an Agent memory operation
    is_memory, memory_reason = self._agent_detector.is_agent_memory_operation(
        node=node,
        var_name=self._extract_receiver_name(node),
    )
    if not is_memory:
        return None  # Not an Agent memory operation
    
    # ... rest of existing context analysis code ...
```

### 3.3 修改: `dangerous_operation_analyzer.py`

添加安全内置函数检查:

```python
# 在文件顶部添加

# Safe builtins that should NEVER trigger AGENT-034
SAFE_BUILTIN_FUNCTIONS: Set[str] = {
    # Async - not code execution
    'asyncio.run', 'asyncio.create_task', 'asyncio.gather',
    'asyncio.wait', 'asyncio.sleep', 'asyncio.wait_for',
    # Regex - pattern matching, not execution
    're.compile', 're.match', 're.search', 're.findall',
    're.sub', 're.split', 're.subn',
    # JSON - parsing, not execution
    'json.loads', 'json.dumps', 'json.load', 'json.dump',
    # Type operations
    'type', 'isinstance', 'issubclass', 'hasattr', 'getattr',
    # Collections
    'list', 'dict', 'set', 'tuple', 'frozenset',
    'len', 'sorted', 'reversed', 'enumerate', 'zip', 'map', 'filter',
    # String operations
    'str', 'repr', 'format',
    # Math
    'int', 'float', 'abs', 'min', 'max', 'sum', 'round',
    # Logging/printing
    'print', 'logging.info', 'logging.debug', 'logging.warning',
    'logging.error', 'logging.critical',
    # Path operations (reading, not execution)
    'pathlib.Path', 'os.path.join', 'os.path.exists',
    'os.path.dirname', 'os.path.basename', 'os.path.isfile',
}


def is_safe_builtin(func_name: str) -> bool:
    """Check if function is a safe Python builtin."""
    if func_name in SAFE_BUILTIN_FUNCTIONS:
        return True
    
    # Check module-level
    parts = func_name.split('.')
    if parts[0] in {'asyncio', 're', 'json', 'logging', 'pathlib'}:
        return True
    
    return False


# 修改 should_flag_tool_input 函数

def should_flag_tool_input(...) -> Tuple[bool, float, str]:
    # ... existing code ...
    
    # === NEW v0.10.0: Safe builtin check ===
    # Check if any "dangerous" call is actually a safe builtin
    result = analyze_tool_for_dangerous_operations(...)
    
    if result.has_dangerous_operation:
        # Double-check if it's a safe builtin
        if is_safe_builtin(result.operation_function):
            return (False, 0.0, f"Safe builtin: {result.operation_function}")
    
    # ... rest of existing code ...
```

---

## 4. 测试计划

### 4.1 单元测试

**文件**: `tests/test_analysis/test_agent_boundary_detector.py`

```python
"""Tests for Agent boundary detection."""

import pytest
from agent_audit.analysis.agent_boundary_detector import (
    AgentBoundaryDetector,
    should_check_agent_034,
    should_check_agent_018,
    AgentContextLevel,
)


class TestAgentBoundaryDetector:
    """Test Agent boundary detection."""
    
    def test_file_with_langchain_import(self):
        """File with LangChain import should be detected as Agent context."""
        source = '''
from langchain.tools import tool

@tool
def my_tool(query: str) -> str:
    return query
'''
        detector = AgentBoundaryDetector()
        result = detector.analyze_file(source)
        
        assert result.is_agent_context is True
        assert result.framework_detected == 'langchain'
        assert result.has_agent_imports is True
    
    def test_file_without_agent_import(self):
        """Regular Python file should not be Agent context."""
        source = '''
import asyncio
import re

async def main():
    result = await asyncio.gather(task1(), task2())
    return result
'''
        detector = AgentBoundaryDetector()
        result = detector.analyze_file(source)
        
        assert result.is_agent_context is False
        assert result.framework_detected is None
    
    def test_safe_builtin_asyncio_run(self):
        """asyncio.run should be detected as safe builtin."""
        detector = AgentBoundaryDetector()
        assert detector.is_safe_builtin_call('asyncio.run') is True
        assert detector.is_safe_builtin_call('asyncio.gather') is True
    
    def test_safe_builtin_re_compile(self):
        """re.compile should be detected as safe builtin."""
        detector = AgentBoundaryDetector()
        assert detector.is_safe_builtin_call('re.compile') is True
        assert detector.is_safe_builtin_call('re.match') is True
    
    def test_dangerous_exec_not_safe(self):
        """exec/eval should NOT be safe builtins."""
        detector = AgentBoundaryDetector()
        assert detector.is_safe_builtin_call('exec') is False
        assert detector.is_safe_builtin_call('eval') is False
        assert detector.is_safe_builtin_call('subprocess.run') is False


class TestAgent018Filtering:
    """Test AGENT-018 Python builtin filtering."""
    
    def test_python_set_is_builtin(self):
        """Python set() should be detected as builtin."""
        import ast
        node = ast.parse("x = set([1, 2, 3])").body[0].value
        
        detector = AgentBoundaryDetector()
        is_builtin, reason = detector.is_python_builtin_collection(node, var_name='seen_ids')
        
        assert is_builtin is True
    
    def test_memory_store_not_builtin(self):
        """memory.add() should NOT be detected as builtin."""
        import ast
        node = ast.parse("memory.add(message)").body[0].value
        
        detector = AgentBoundaryDetector()
        is_builtin, _ = detector.is_python_builtin_collection(node)
        is_memory, _ = detector.is_agent_memory_operation(node)
        
        assert is_builtin is False
        assert is_memory is True
    
    def test_visited_set_is_builtin(self):
        """visited.add() should be detected as builtin (tracking set)."""
        import ast
        node = ast.parse("visited.add(node_id)").body[0].value
        
        detector = AgentBoundaryDetector()
        is_builtin, reason = detector.is_python_builtin_collection(node, var_name='visited')
        
        assert is_builtin is True


class TestShouldCheckFunctions:
    """Test the should_check_* decision functions."""
    
    def test_agent_034_requires_imports(self):
        """AGENT-034 should not fire without Agent imports."""
        should_check, reason = should_check_agent_034(
            func_name="my_tool",
            has_agent_imports=False,
            is_tool_function=True,
            call_name="subprocess.run",
        )
        assert should_check is False
    
    def test_agent_034_requires_tool_decorator(self):
        """AGENT-034 should not fire without @tool decorator."""
        should_check, reason = should_check_agent_034(
            func_name="my_function",
            has_agent_imports=True,
            is_tool_function=False,
            call_name="subprocess.run",
        )
        assert should_check is False
    
    def test_agent_034_skips_asyncio_run(self):
        """AGENT-034 should not fire for asyncio.run()."""
        should_check, reason = should_check_agent_034(
            func_name="my_tool",
            has_agent_imports=True,
            is_tool_function=True,
            call_name="asyncio.run",
        )
        assert should_check is False
    
    def test_agent_034_fires_for_subprocess(self):
        """AGENT-034 should fire for subprocess.run in @tool."""
        should_check, reason = should_check_agent_034(
            func_name="my_tool",
            has_agent_imports=True,
            is_tool_function=True,
            call_name="subprocess.run",
        )
        assert should_check is True
```

### 4.2 集成测试

```python
"""Integration tests for AGENT-034/018 semantic layer."""

import pytest
from agent_audit.scanners.python_scanner import PythonScanner


class TestAgent034SemanticLayer:
    """Test AGENT-034 with semantic layer."""
    
    def test_asyncio_run_not_flagged(self):
        """asyncio.run() in @tool should NOT trigger AGENT-034."""
        source = '''
from langchain.tools import tool

@tool
def async_tool(query: str) -> str:
    """Run async query."""
    result = asyncio.run(process_query(query))
    return result
'''
        scanner = PythonScanner()
        findings = scanner.scan_source(source, "test.py")
        
        agent_034 = [f for f in findings if f.rule_id == 'AGENT-034']
        assert len(agent_034) == 0
    
    def test_re_compile_not_flagged(self):
        """re.compile() in @tool should NOT trigger AGENT-034."""
        source = '''
from langchain.tools import tool

@tool
def regex_tool(pattern: str) -> str:
    """Compile regex pattern."""
    regex = re.compile(pattern)
    return str(regex.pattern)
'''
        scanner = PythonScanner()
        findings = scanner.scan_source(source, "test.py")
        
        agent_034 = [f for f in findings if f.rule_id == 'AGENT-034']
        assert len(agent_034) == 0
    
    def test_subprocess_run_flagged(self):
        """subprocess.run() in @tool SHOULD trigger AGENT-034."""
        source = '''
from langchain.tools import tool

@tool
def shell_tool(command: str) -> str:
    """Run shell command."""
    result = subprocess.run(command, shell=True, capture_output=True)
    return result.stdout.decode()
'''
        scanner = PythonScanner()
        findings = scanner.scan_source(source, "test.py")
        
        agent_034 = [f for f in findings if f.rule_id == 'AGENT-034']
        assert len(agent_034) >= 1


class TestAgent018SemanticLayer:
    """Test AGENT-018 with semantic layer."""
    
    def test_python_set_not_flagged(self):
        """Python set() should NOT trigger AGENT-018."""
        source = '''
from langchain.agents import AgentExecutor

def process_items(items):
    seen = set()
    for item in items:
        if item.id not in seen:
            seen.add(item.id)
'''
        scanner = PythonScanner()
        findings = scanner.scan_source(source, "test.py")
        
        agent_018 = [f for f in findings if f.rule_id == 'AGENT-018']
        assert len(agent_018) == 0
    
    def test_memory_add_flagged(self):
        """memory.add() SHOULD trigger AGENT-018."""
        source = '''
from langchain.memory import ConversationBufferMemory

memory = ConversationBufferMemory()
memory.add_message(user_input)  # Should flag
'''
        scanner = PythonScanner()
        findings = scanner.scan_source(source, "test.py")
        
        agent_018 = [f for f in findings if f.rule_id == 'AGENT-018']
        assert len(agent_018) >= 1
```

### 4.3 Benchmark 验证

```bash
# 运行 benchmark
cd tests/benchmark
python run_benchmark.py

# 预期结果:
# SWE-agent: 54 → ~20 (AGENT-034 从 33 降到 ~6)
# Generative Agents: 11 → 0 (AGENT-018 全部消除)
```

---

## 5. 回滚计划

如果新代码引入回归，可以通过环境变量禁用语义层:

```python
import os

USE_SEMANTIC_LAYER = os.environ.get('AGENT_AUDIT_SEMANTIC_LAYER', 'true').lower() == 'true'

def _check_tool_no_input_validation(...):
    if USE_SEMANTIC_LAYER:
        # v0.10.0 语义层逻辑
        if not self._has_agent_imports:
            return None
    else:
        # v0.9.0 原有逻辑
        pass
```

---

## 6. 成功指标

| 指标 | 当前 (v0.9.0) | 目标 (v0.10.0) | 验收标准 |
|-----|--------------|---------------|---------|
| SWE-agent 总 findings | 54 | ≤25 | -54% |
| SWE-agent AGENT-034 | 33 | ≤6 | -82% |
| Generative Agents 总 findings | 11 | 0 | -100% |
| Generative Agents AGENT-018 | 11 | 0 | -100% |
| OWASP 覆盖 | 10/10 | 10/10 | 保持 |
| 真阳性保留率 | 100% | 100% | 无回归 |

---

## 7. 实施检查清单

- [ ] 创建 `agent_boundary_detector.py`
- [ ] 添加单元测试 `test_agent_boundary_detector.py`
- [ ] 修改 `python_scanner.py` - 添加文件级检测
- [ ] 修改 `python_scanner.py` - 修改 `_check_tool_no_input_validation`
- [ ] 修改 `python_scanner.py` - 修改 `_check_memory_poisoning`
- [ ] 修改 `dangerous_operation_analyzer.py` - 添加安全内置检查
- [ ] 运行完整测试套件 (`pytest tests/`)
- [ ] 运行 benchmark 验证
- [ ] 更新版本号到 v0.10.0
- [ ] 更新 CHANGELOG

---

**文档版本**: 1.0  
**最后更新**: 2026-02-05
