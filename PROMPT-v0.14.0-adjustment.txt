数据很漂亮，但有一个需要诚实面对的问题

先说好的：Recall 68.2%、Precision 83.3%、F1 75.0%、Taint Accuracy 31.8%——从 v0.4.1 baseline 一路走来，这是实质性的进步。三个版本的轨迹非常健康：

Recall Precision Taint Acc

v0.4.1 17.6% - 0.0%

v0.13.0 50.0% 78.6% 9.1%

v0.14.0 68.2% 83.3% 31.8%

Precision 在 Recall 提升的同时还涨了 4.7pp，说明不是靠"什么都报"来刷 Recall。

但第 3 和第 4 点改动需要警惕

Fixed oracle line numbers in KNOWN-001, KNOWN-002, KNOWN-005

Added source type equivalence in oracle_eval.py: user_input ≈ llm_output

这两项改的不是检测引擎，而是benchmark 本身。

Oracle 行号修正如果确实是 oracle 写错了，那没问题——benchmark 本身也需要 debug。但需要确认：是 oracle 的行号原本就标错了，还是因为检测引擎报的行号和 oracle 不一致所以去改 oracle 来迁就？如果是后者，就是在拟合评测集。

user_input ≈ llm_output 等价性更微妙。从安全语义上说，这个等价有一定道理——两者都是不可信外部输入。但这个变更让 oracle 评估变得更宽松了，Taint Accuracy 从 9.1% 跳到 31.8% 有多少是因为检测能力提升、多少是因为评估标准放松？

建议：在 benchmark 报告中分离两个数字：

Strict Taint Accuracy（原始 oracle，不做等价映射）

Relaxed Taint Accuracy（含 source type 等价）

这样每个版本的改进中，工具能力提升和评估标准调整的贡献是透明的。这不是说等价映射不合理，而是作为学术级 benchmark 需要这种可追溯性。

Sink type mapping 修复是纯正的改进

eval() → code_execution 而不是 eval——这是检测引擎的输出和 oracle 术语的对齐，是合理的 normalization，不存在拟合问题。Source type 在 method call chain 中的传播保持也是 taint tracker 的实质性能力增强。

两个关键追问：

KNOWN-001 和 KNOWN-002 现在能检出了吗？ 上个版本它们还是 0% Recall，这次你改了它们的 oracle 行号，但没明确说检测结果是否翻转。

Set B（MCP）和 Set C（Data）的分类 Recall 是多少？ 整体 Recall 68.2% 可能掩盖了 Set B 仍然为 0% 的问题——这在 context 文档中被标为 P0。

总结

v0.14.0 的核心技术改进（sink mapping、source propagation）是扎实的。但 benchmark 侧的修改（oracle 行号、source 等价性）引入了评估标准的变化，需要用 strict/relaxed 双指标来保持透明度。下一步应该聚焦 Recall 最后的 12pp gap，优先确认 Set B/C 的分类表现和 KNOWN-001/002 的检出状态。